print(pbc.imp.out)
pbc.imp.out = aas.data.frame(
cbind(round(rev(sort(imp)),4),
round(pbc.err,4),
round(-diff(c(0.5,pbc.err)),4)),
row.names = pnames.order)
colnames(pbc.imp.out) = c("Imp", "Err", "Drop Err")
print(pbc.imp.out)
pbc.imp.out = as.data.frame(
cbind(round(rev(sort(imp)),4),
round(pbc.err,4),
round(-diff(c(0.5,pbc.err)),4)),
row.names = pnames.order)
colnames(pbc.imp.out) = c("Imp", "Err", "Drop Err")
print(pbc.imp.out)
equire(randomForestSRC)
data("pbc")
pbc.f = as.formula("Surv(days,status)~.")
pbc.out = rfsrc(pbc.f, pbc, ntree = 1000,
splitrule = "logrankscore", forest = T)
plot(pbc.out)
pbc2.out = rfsrc(Surv(days,status)~.-ascites-treatment-spiders-edema-sex,
pbc, ntree = 1000,
splitrule = "logrankscore", forest = T)
require(randomForestSRC)
data("pbc")
pbc.f = as.formula("Surv(days,status)~.")
pbc.out = rfsrc(pbc.f, pbc, ntree = 1000,
splitrule = "logrankscore", forest = T)
plot(pbc.out)
pbc2.out = rfsrc(Surv(days,status)~.-ascites-treatment-spiders-edema-sex,
pbc, ntree = 1000,
splitrule = "logrankscore", forest = T)
ntree=1000
imp = pbc.out$importance
pnames = pbc.out$xvar.names
pnames.order = pnames[rev(order(imp))]
n.pred = length(pnames.order)
pbc.err = rep(0, n.pred)
for (k in 1:n.pred){
rsf.f = "Surv(days,status)~"
rsf.f = as.formula(paste(rsf.f,
paste(pnames.order[1:k], collapse="+")))
pbc.err[k] = rfsrc(rsf.f, pbc, ntree = ntree,
splitrule = "logrankscore")$err.rate[ntree]
}
pbc.imp.out = as.data.frame(
cbind(round(rev(sort(imp)),4),
round(pbc.err,4),
round(-diff(c(0.5,pbc.err)),4)),
row.names = pnames.order)
colnames(pbc.imp.out) = c("Imp", "Err", "Drop Err")
print(pbc.imp.out)
ntree=3000
imp = pbc.out$importance
pnames = pbc.out$xvar.names
pnames.order = pnames[rev(order(imp))]
n.pred = length(pnames.order)
pbc.err = rep(0, n.pred)
for (k in 1:n.pred){
rsf.f = "Surv(days,status)~"
rsf.f = as.formula(paste(rsf.f,
paste(pnames.order[1:k], collapse="+")))
pbc.err[k] = rfsrc(rsf.f, pbc, ntree = ntree,
splitrule = "logrankscore")$err.rate[ntree]
}
pbc3.imp.out = as.data.frame(
cbind(round(rev(sort(imp)),4),
round(pbc.err,4),
round(-diff(c(0.5,pbc.err)),4)),
row.names = pnames.order)
colnames(pbc3.imp.out) = c("Imp", "Err", "Drop Err")
print(pbc3.imp.out)
x=rfsrc(Surv(days,status)~bili+copper+albumin+prothrombin+sgot+age, splitrule="logrank",)
x=rfsrc(Surv(days,status)~bili+copper+albumin+prothrombin+sgot+age, veteran, splitrule="logrank",
ntree=3000)
x=rfsrc(Surv(days,status)~bili+copper+albumin+prothrombin+sgot+age, pbc, splitrule="logrank",
ntree=3000)
x
plot(x)
x$err.rate
plot(x$err.rate[1000:3000]
)
source("http://www.math.ntnu.no/inla/givemeINLA.R")
install.packages(INLA)
install.packages(inla)
inla.update()
inla.upgrade
inla.upgrade()
install.packages("runjags")
?runjags
??runjags
install.packages("dclone")
??dclone
source('/home2/yannick2/github/Spikes/R_survival/cox_companion.R', echo=TRUE)
source('/home2/yannick2/github/Spikes/R_survival/cox_companion.R', echo=TRUE)
source('/home2/yannick2/github/Spikes/R_survival/cox_companion.R', echo=TRUE)
source('/home2/yannick2/github/Spikes/R_survival/cox_companion.R', echo=TRUE)
source('/home2/yannick2/github/Spikes/R_survival/cox_companion.R', echo=TRUE)
source('/home2/yannick2/github/Spikes/R_survival/cox_companion.R', echo=TRUE)
source('/home2/yannick2/github/Spikes/Installs/R.install.packages.R', echo=TRUE)
source('/home2/yannick2/github/Spikes/rjags/bugs book/sp2_linreg.R', echo=TRUE)
source('/home2/yannick2/github/Spikes/rjags/bugs book/sp2_linreg.R', echo=TRUE)
source('/home2/yannick2/github/Spikes/rjags/bugs book/sp2_linreg.R', echo=TRUE)
source('/home2/yannick2/github/Spikes/rjags/bugs book/sp2_linreg.R', echo=TRUE)
plot(x,y)
source('/home2/yannick2/github/Spikes/rjags/bugs book/sp2_linreg.R', echo=TRUE)
plot(x,y)
mean(x)
mean(y)-mean(x)
source('/home2/yannick2/github/Spikes/rjags/bugs book/sp2_linreg.R', echo=TRUE)
plot(x,y)
source('/home2/yannick2/github/Spikes/rjags/bugs book/sp2_linreg.R', echo=TRUE)
plot(x,y)
rbern
source('/home2/yannick2/github/Spikes/rjags/bugs book/sp2_linreg.R', echo=TRUE)
source('/home2/yannick2/github/Spikes/rjags/bugs book/sp2_linreg.R', echo=TRUE)
options(repos = c(getOption("repos"), rstan = "http://wiki.stan.googlecode.com/git/R")) install.packages('rstan', type = 'source')
options(repos = c(getOption("repos"), rstan = "http://wiki.stan.googlecode.com/git/R"))
install.packages('rstan', type = 'source')
options(repos = c(getOption("repos"), rstan = "http://wiki.stan.googlecode.com/git/R")) install.packages('rstan', type = 'source')
?options
options("repos")
install.packages('rstan', type = 'source')
install.packages('rstan')
options (repos =c(CRAN="https://mran.revolutionanalytics.com/snapshot/2015-07-01"))
install.packages("rstan")
Sys.setenv(MAKEFLAGS = "-j4")
install.packages("rstan", dependencies = TRUE)
devtools::install_github("https://github.com/stan-dev/rstan")
devtools::install_github("https://github.com/stan-dev/rstan", username="yama1968")
devtools::install_github("https://github.com/stan-dev/rstan")
devtools::install_github("stan-dev/rstan")
install.packages('RcppEigen')
?seed
random.seed
library(caret)
data(GermanCredit)
set.seed(1234)
Train <- createDataPartition(GermanCredit$Class, p=0.6, list=FALSE)
training <- GermanCredit[Train,]
testing <- GermanCredit[-Train,]
mod_fit_one <- glm(Class ~ Age + ForeignWorker + Property.RealEstate +
Housing.Own + CreditHistory.Critical,
data = training,
family = "binomial")
summary(mod_fit_one)
exp(coef(mod_fit_one))
library(pROC)
install.packages("pROC")
install.packages("ROCR")
prob <- predict(mod_fit_one, newdata=testing, type="response")
pred <- prediction(prob, testing$Class)
perf <- performance(pred, measure="tpr", x.measure="fpr")
plot(perf)
auc <- performance(pred, measure="auc")
auc <- auc@y.values[[1]]
auc
prob <- predict(mod_fit_one, newdata=testing, type="response")
pred <- predict(prob, testing$Class)
perf <- performance(pred, measure="tpr", x.measure="fpr")
plot(perf)
auc <- performance(pred, measure="auc")
auc <- auc@y.values[[1]]
auc
library(ROCR)
prob <- predict(mod_fit_one, newdata=testing, type="response")
pred <- prediction(prob, testing$Class)
perf <- performance(pred, measure="tpr", x.measure="fpr")
plot(perf)
auc <- performance(pred, measure="auc")
auc <- auc@y.values[[1]]
auc
set.seed(1234)
Train <- createDataPartition(GermanCredit$Class, p=0.6, list=FALSE)
training <- GermanCredit[Train,]
testing <- GermanCredit[-Train,]
mod_fit_one <- glm(Class ~ ForeignWorker + Property.RealEstate +
Housing.Own + CreditHistory.Critical,
data = training,
family = "binomial")
summary(mod_fit_one)
exp(coef(mod_fit_one))
library(ROCR)
prob <- predict(mod_fit_one, newdata=testing, type="response")
pred <- prediction(prob, testing$Class)
perf <- performance(pred, measure="tpr", x.measure="fpr")
plot(perf)
auc <- performance(pred, measure="auc")
auc <- auc@y.values[[1]]
auc
get.auc <- function(model) {
prob <- predict(model, newdata=testing, type="response")
pred <- prediction(prob, testing$Class)
perf <- performance(pred, measure="tpr", x.measure="fpr")
plot(perf)
auc <- performance(pred, measure="auc")
auc <- auc@y.values[[1]]
auc
}
get.auc(mod_fit_one)
mod_fit_two <- glm(Class ~ ., data=training, family="binomial")
get.auc(mod_fit_two)
dim(training)
mod_fit_two
summary(mod_fit_two)
three <- glm(Class ~ Amount + InstallmentRatePercentage + Telephone + ForeignWorker +
CheckingAccountStatus.lt.0 + CheckingAccountStatus.0.to.200 +
CheckingAccountStatus.gt.200 +
CreditHistory.NoCredit.AllPaid + CreditHistory.ThisBank.AllPaid +
CreditHistory.PaidDuly + SavingsAccountBonds.lt.100 +
OtherInstallmentsPlans.Bank,
data=training,
family="binomial")
summary(three)
get.auc(three)
three <- glm(Class ~ Amount + InstallmentRatePercentage + Telephone + ForeignWorker +
CheckingAccountStatus.lt.0 + CheckingAccountStatus.0.to.200 +
CheckingAccountStatus.gt.200 +
CreditHistory.NoCredit.AllPaid + CreditHistory.ThisBank.AllPaid +
CreditHistory.PaidDuly + SavingsAccountBonds.lt.100 +
OtherInstallmentPlans.Bank,
data=training,
family="binomial")
summary(three)
get.auc(three)
get.auc(mod_fit_two)
four <- glm(Class ~ . + (.) * (.),
data=training,
family="binomial")
summary(four)
get.auc(four)
summary(four)
summary(four)
l=c("a","b","c")
l*l
lapply(l, function(x){ lapply(l, function(y) {paste(x,y,sep="*")})})
sapply(l, function(x){ sapply(l, function(y) {paste(x,y,sep="*")})})
collet(sapply(l, function(x){ sapply(l, function(y) {paste(x,y,sep="*")})}))
(apply(l, function(x){ apply(l, function(y) {paste(x,y,sep="*")})}))
apply
?apply
data("iris")
library(caret)
data("GermanCredit")
dim(GermanCredit)
source('/home2/yannick2/github/Spikes/R/logistic.regression.test01.R', echo=TRUE)
three
summary(three)
get.auc(mod_fit_one)
get.auc(mod_fit_two)
get.auc(three)
summary(mod_fit_two)
library(readr)
library(xgboost)
devtools::install_github('dmlc/xgboost',subdir='R-package')
install.packages("readr")
library(glmnet)
library(dplyr)
library(caret)
library(doMC)
registerDoMC(cores=4)
data(iris)
X <- as.matrix(iris %>% select(-Species))
y <- as.factor(iris$Species)
clf1 <- glmnet(X, y,
family = "multinomial")
plot(clf1)
cv.clf1 <- cv.glmnet(X,y,
family = "multinomial",
parallel = T)
plot(cv.clf1)
clf2 <- train(Species~.,
data = iris,
trControl = trainControl("cv", 7),
method = "glmnet",
tuneLength = 20)
plot(clf2)
predict(clf2, iris, type="prob")
require(h2o)
l=h2o.init()
h2o.shutdown(l)
l=h2o.init(nthreads=-1)
l=h2o.init(nthreads=-1)
h2o.shutdown(l)
?"h2o.init"
l=h2o.init(nthreads=-1,max_mem_size="10G")
h2o.shutdown(l)
l=h2o.init(nthreads=-1,max_mem_size="12G")
h2o.demo(kmeans)
?demo
demo()
demo(h2o.deeplearning())
demo(h2o.naiveBayes())
demo(h2o.glm)
demo(h2o.gbm)
rm(list=ls())
l
l=h2o.init(nthreads=-1,max_mem_size="12G")
require(h2o)
l=h2o.init(nthreads=-1,max_mem_size="12G")
??h2o
h2o.shutdown(l)
install.packages(c("deepnet", "darch"))
inputs <- matrix(c(0,0,0,1,1,0,1,1),ncol=2,byrow=TRUE)
outputs <- matrix(c(0,1,1,0),nrow=4)
darch <- newDArch(c(2,4,1),batchSize=2)
require(darch)
darch <- newDArch(c(2,4,1),batchSize=2)
darch <- preTrainDArch(darch,inputs,maxEpoch=1000)
layers <- getLayers(darch)
for(i in length(layers):1){
layers[[i]][[2]] <- sigmoidUnitDerivative
}
setLayers(darch) <- layers
rm(layers)
setFineTuneFunction(darch) <- backpropagation
darch <- fineTuneDArch(darch,inputs,outputs,maxEpoch=1000)
darch <- darch <- getExecuteFunction(darch)(darch,inputs)
outputs <- getExecOutputs(darch)
cat(outputs[[length(outputs)]])
outputs
require(deepnet)
?newDArch
?h2O
install.packages("xkcd")
require(xdkcd)
require(xkcd)
data(mtcars)
p <- ggplot() + geom_point(aes(mpg, wt), data=mtcars) + theme_xkcd()
vignette("xkcd-intro")
library(extrafont)
download.file("http://simonsoftware.se/other/xkcd.ttf",
dest="xkcd.ttf", mode="wb")
system("mkdir ~/.fonts")
system("cp xkcd.ttf ~/.fonts")
font_import(pattern = "[X/x]kcd", prompt=FALSE)
fonts()
fonttable()
if(.Platform$OS.type != "unix") {
## Register fonts for Windows bitmap output
loadfonts(device="win")
} else {
loadfonts()
}
p <- ggplot() + geom_point(aes(mpg, wt), data=mtcars) + theme_xkcd()
p
xrange <- range(mtcars$mpg)
yrange <- range(mtcars$wt)
set.seed(123) # for reproducibility
p <- ggplot() + geom_point(aes(mpg, wt), data=mtcars) + xkcdaxis(xrange,yrange)
p
glm
?glm
require(glmnet)
?cv.glmnet
set.seed(1234)
n <- 20
x <- runif(n, -1, 1)
X <- model.matrix(~x)
beta <- c(2, -1)
mu <- crossprod(t(X), beta)
Y <- rpois(n, exp(mu))
foo.model <- function() {
for (i in 1:n) {
Y[i] ~ dpois(lambda[i])
log(lambda[i]) <- inprod(X[i,], beta[1,])
}
for (j in 1:np) {
beta[1,j] ~ dnorm(0, 0.001)
}
}
dat <- list(Y=Y, X=X, n=n, np=ncol(X))
load.module("foo")
m <- jags.fit(dat, "beta", foo.model)
cl <- makePSOCKcluster(3)
## load glm module
tmp <- clusterEvalQ(cl, library(dclone))
parLoadModule(cl, "foo")
pm <- jags.parfit(cl, dat, "beta", foo.model)
## chains are not identical -- this is good
pm[1:2,]
summary(pm)
rm(list=ls())
library('dclone')
library('rjags')
library('snow')
set.seed(1234)
n <- 20
x <- runif(n, -1, 1)
X <- model.matrix(~x)
beta <- c(2, -1)
mu <- crossprod(t(X), beta)
Y <- rpois(n, exp(mu))
foo.model <- function() {
for (i in 1:n) {
Y[i] ~ dpois(lambda[i])
log(lambda[i]) <- inprod(X[i,], beta[1,])
}
for (j in 1:np) {
beta[1,j] ~ dnorm(0, 0.001)
}
}
dat <- list(Y=Y, X=X, n=n, np=ncol(X))
load.module("foo")
m <- jags.fit(dat, "beta", foo.model)
cl <- makePSOCKcluster(3)
## load glm module
tmp <- clusterEvalQ(cl, library(dclone))
parLoadModule(cl, "foo")
pm <- jags.parfit(cl, dat, "beta", foo.model)
## chains are not identical -- this is good
pm[1:2,]
summary(pm)
library('dclone')
library('rjags')
library('snow')
set.seed(1234)
n <- 20
x <- runif(n, -1, 1)
X <- model.matrix(~x)
beta <- c(2, -1)
mu <- crossprod(t(X), beta)
Y <- rpois(n, exp(mu))
foo.model <- function() {
for (i in 1:n) {
Y[i] ~ dpois(lambda[i])
log(lambda[i]) <- inprod(X[i,], beta[1,])
}
for (j in 1:np) {
beta[1,j] ~ dnorm(0, 0.001)
}
}
dat <- list(Y=Y, X=X, n=n, np=ncol(X))
# load.module("foo")
m <- jags.fit(dat, "beta", foo.model)
cl <- makePSOCKcluster(3)
## load glm module
tmp <- clusterEvalQ(cl, library(dclone))
# parLoadModule(cl, "foo")
pm <- jags.parfit(cl, dat, "beta", foo.model)
## chains are not identical -- this is good
pm[1:2,]
summary(pm)
library('dclone')
library('rjags')
library('snow')
set.seed(1234)
n <- 20
x <- runif(n, -1, 1)
X <- model.matrix(~x)
beta <- c(2, -1)
mu <- crossprod(t(X), beta)
Y <- rpois(n, exp(mu))
foo.model <- function() {
for (i in 1:n) {
Y[i] ~ dpois(lambda[i])
log(lambda[i]) <- inprod(X[i,], beta[1,])
}
for (j in 1:np) {
beta[1,j] ~ dnorm(0, 0.001)
}
}
dat <- list(Y=Y, X=X, n=n, np=ncol(X))
# load.module("foo")
m <- jags.fit(dat, "beta", foo.model)
# cl <- makePSOCKcluster(3)
## load glm module
# tmp <- clusterEvalQ(cl, library(dclone))
# parLoadModule(cl, "foo")
pm <- jags.parfit(4, dat, "beta", foo.model)
## chains are not identical -- this is good
pm[1:2,]
summary(pm)
pm <- dc.parfit(4, dat, "beta", foo.model, flavour="jags", n.chains=4)
## chains are not identical -- this is good
pm[1:2,]
summary(pm)
n.chains=4, n.clones=4)
pm <- dc.parfit(4, dat, "beta", foo.model, flavour="jags",
n.chains=4, n.clones=4)
pm <- dc.parfit(4, dat, "beta", foo.model, flavour="jags",
n.chains=4, n.clones=1)
pm <- dc.parfit(4, dat, "beta", foo.model, flavour="jags",
n.chains=4, n.clones=8)
pm <- jags.parfit(4, dat, "beta", foo.model, flavour="jags",
n.chains=4)
summary(pm)
install.packages("forecast")
p = c("caret", "e1071", "rjags", "dclone", "data.table", "dplyr",
"ggplot2", "Hmisc", "extraTrees", "Rcpp", "devtools",
"snow", "foreach", "reshape2", "survival", "randomForest",
"tidyr", "car", "glmnet", "assertr", "doMC",
"optparse", "forecast")
p <- p[ ! p %in% installed.packages()]
print (p)
?dpois
rpois(40,24)
y<-rpois(40,24)
hist(y, breaks=4*(0:10))
hist(y, breaks=2*(0:20))
hist(gamma(10,10), breaks=2*(0:20))
hist(rgamma(10,10), breaks=2*(0:20))
setwd("~/github/Spikes/rjags/bugs book")
source('/home2/yannick2/github/Spikes/rjags/bugs book/arma2.1.r2jags.R', echo=TRUE)
m.sd <- m$BUGSoutput$sd$m
plot(data$y, m.means+2*m.sd, m.means-2$sd, lty=c(1,3,3))
plot(data$y, m.means+2*m.sd, m.means-2*sd, lty=c(1,3,3))
plot(data$y, m.means+2*m.sd, m.means-2*m.sd, lty=c(1,3,3))
ts.plot(data$y, m.means+2*m.sd, m.means-2*m.sd, lty=c(1,3,3))
ts.plot(ts(data$y), ts(m.means+2*m.sd), ts(m.means-2*m.sd), lty=c(1,3,3))
source('~/github/Spikes/rjags/bugs book/ar1.r2jags.R', echo=TRUE)
